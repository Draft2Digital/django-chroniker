{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nDjango Chroniker is a Python package that allows\nyou to use cron to schedule Django management commands through Django's admin.\n\n\nCreating cron jobs for Django apps can be a pain, annoying and repetitive.\nWith django-chroniker you simply create a single cron job to run every minute,\npoint it at your site's directory and run \nmanage.py cron\n.\nThen, you can create, update and delete jobs through Django's admin.\n\n\nThis is a fork of Weston Nielson's \nChronograph\n project.\n\n\nFeatures\n\n\nThis package contains the following improvements over the parent Chronograph project:\n\n\n\n\n\n\nAllow Django management commands to record their percent-progress and display it in admin. e.g.\n\n\nfrom chroniker.models import Job\nJob.update_progress(total_parts=77, total_parts_complete=13)\n\n\n\n\n\n\n\nImproved logging of management command stdout and stderr, and efficiently displaying these in admin.\n\n\n\n\nCreation of the \nMonitor\n model, a proxy of the \nJob\n model, to allow easier setup of system and database state monitoring.\n\n\nAddition of a model for documenting inter-job dependencies as well as flags for controlling job behavior based on these dependencies. e.g. You can configure one job to not run until another job has successfully run, or run at a later date.\n\n\nImproved support for coordinating job execution in a multi-server environment. e.g. You can configure a job to only run on a specific host or any host.\n\n\n\n\nUnlike some scheduling systems, Chroniker attempts to ensure that every job may\nhave at most only one running instance at any given time. This greatly\nsimplifies scheduling, but necessarily imposes some restrictions. If you need\nto schedule multiple instances of a task to run simultaneously, especially in\nreal-time, consider using a system like \nCelery\n\ninstead.\n\n\nInstallation\n\n\nInstall the package from PyPI via pip with:\n\n\npip install django-chroniker\n\n\n\nor directly from github with (warning, this may be less stable than the official release on PyPI):\n\n\npip install https://github.com/chrisspen/django-chroniker/tarball/master\n\n\n\nAdd 'chroniker' and 'django.contrib.sites' to the INSTALLED_APPS list in your settings.py.\n\n\nIf you're using Django 1.7 or higher (which you should be), install Chroniker's models by running:\n\n\npython manage.py migrate\n\n\n\notherwise run:\n\n\npython manage.py syncdb\n\n\n\nUsage\n\n\nIn your admin, creating and jobs under the Chroniker section.\n\n\nIf you're in a development setting, you can test your Chroniker-based cron jobs by first checking \"force run\" on your job, and then running:\n\n\npython manage.py cron\n\n\n\nAlso, you can simulate a simple cron server that will automatically run any pending cron jobs every N seconds with:\n\n\npython manage.py cronserver\n\n\n\nTo allow Chroniker can send email, ensure you have valid email parameters in your settings.py. A very basic example using Gmail might be:\n\n\nEMAIL_USE_TLS = True\nEMAIL_HOST = 'smtp.gmail.com'\nEMAIL_HOST_USER = 'myusername@gmail.com'\nEMAIL_HOST_PASSWORD = os.environ['GMAILPASS']\n\n\n\nYou can customize the \"name\" Chroniker uses in its emails with:\n\n\nCHRONIKER_EMAIL_SENDER = 'Jon Doe'\n\n\n\nYou can also specify a separate email user for Chroniker with:\n\n\nCHRONIKER_EMAIL_HOST_USER = 'someotherusername@otherdomain.com'\n\n\n\nWhen installing Chroniker in a production environment, you'll need to add a single cron job that calls \nbin/chroniker\n or \npython manage.py cron\n.\nWithin the call, you'll need to specify where this script is installed, where your Python virtual environment is located (if you're using one), and where your Django project is located.\nAn example of this might be: \n\n\n* * * * * /usr/local/myproject/bin/chroniker -e /usr/local/myproject/.env/bin/activate_this.py -p /usr/local/myproject\n\n\n\nRun \nbin/chroniker --help\n for a full listing of options.\n\n\nSettings\n\n\nDepending on your usage, there are a few options that could greatly help or harm job scheduling.\n\n\nCHRONIKER_USE_PID\n\n\n\n\nIf this is set to True, the \ncron\n management command will wait for the previous run to complete using a local PID file.\n\n\n\n\nCHRONIKER_SELECT_FOR_UPDATE\n\n\n\n\nIf this is set to True, the Job record \nwill be locked\n when updating job status in the database. This may not be supported on all database backends.\n\n\n\n\nCHRONIKER_CHECK_LOCK_FILE\n\n\n\n\nIf this is set to True, chroniker will check for a local lockfile to determine if the job is running or not.\n\n\nYou should set this to True in a single-server environment, and False in a multi-server environment.\n\n\n\n\nMaintenance\n\n\nIf you'd like an easy way to delete old job logs, there is a management command\nthat will do it for you: \ncron_clean\n.  You can use it like so::\n\n\npython manage.py cron_clean [weeks|days|hours|minutes] [integer]\n\n\n\nSo, if you want to remove all jobs that are older than a week, you can do the\nfollowing::\n\n\npython manage.py cron_clean weeks 1\n\n\n\nSince this is just a simple management command, you can also easily add it to\n\nchroniker\n, via the admin, so that it will clear out old logs\nautomatically.\n\n\nTools\n\n\nThere is anther included management command, \ncronserver\n which can be used\nto test the periodic running of jobs.  It'll print out information to the\nscreen about which job are due and also run them.  Here is how you would use\nit::\n\n\npython manage.py cronserver\n\n\n\nThis will start up a process that will check for and run any jobs that are due\nevery 60 seconds.  The interval can be changed by simply passing the number of\nseconds in between runs.  For example, to make the process check for due jobs\nevery 2 minutes, you would run::\n\n\npython manage.py cronserver 120\n\n\n\nArchitecture\n\n\nThe trickiest thing to get right in \nChroniker\n is the ability to properly\nmanage the state of a \nJob\n, i.e. reliably determining whether or not a\njob is or isn't running, if it has been killed or terminated prematurely.  In\nthe first version of \nChroniker\n this issue was \"solved\" by keeping track\nof the PID of each running job and using the \nps\n command to have the\noperating system tell us if the job was still running.  However, this route was\nless than ideal, for a few reasons, but most importantly because isn't wasn't\ncross-platform.  Additionally, using a series of \nsubprocess.Popen\n calls was\nleading to path-related issues for some users, even on \"supported\" platforms.\n\n\nNewer version of \nChroniker\n have attempted to solve this problem in the\nfollowing way:\n\n\n1.  Get a list of ``Job``\\s that are \"due\"\n2.  For each ``Job``, launch a ``multiprocessing.Process`` instance, which\n    internally calls ``django.core.management.call_command``\n3.  When the ``Job`` is run, we spawn a ``threading.Thread`` instance whose\n    sole purpose is to keep track of a lock file.  This thread exists only\n    while the Job is running and updates the file every second.  We store\n    the path to this temporary file (an instance of\n    ``tempfile.NamedTemporaryFile``) on the ``Job`` model (which is then\n    stored in the database).  When we want to check if a ``Job`` is running\n    we do the following:\n\n    1.  If ``is_running`` equals ``True``, and ``lock_file`` point to a\n        file, then:\n\n        1.  If the lock file actually exists and has been updated more\n            recently than ``CHRONIKER_LOCK_TIMEOUT`` seconds, then we\n            can assume that the ``Job`` is still running\n    2.  Else we assume the ``Job`` is not running and update the database\n        accordingly\n\n\n\nThis new method should would much more reliably across all platforms that\nsupport the threading and multiprocess libraries.\n\n\nDevelopment\n\n\nTests require the Python development headers to be installed, which you can install on Ubuntu with:\n\n\nsudo apt-get install python-dev python3-dev python3.4-dev\n\n\n\nTo run unittests across multiple Python versions, install:\n\n\nsudo apt-get install python3.4-minimal python3.4-dev python3.5-minimal python3.5-dev\n\n\n\nTo run all \ntests\n:\n\n\nexport TESTNAME=; tox\n\n\n\nTo run tests for a specific environment (e.g. Python 2.7 with Django 1.4):\n\n\nexport TESTNAME=; tox -e py27-django15\n\n\n\nTo run a specific test:\n\n\nexport TESTNAME=.testTimezone2; tox -e py27-django15\n\n\n\nTo run the \ndocumentation server\n locally:\n\n\nmkdocs serve -a :9999\n\n\n\nTo \ndeploy documentation\n, run:\n\n\nmkdocs gh-deploy --clean\n\n\n\nTo build and deploy a versioned package to PyPI, verify \nall unittests are passing\n, and then run:\n\n\npython setup.py sdist\npython setup.py sdist upload", 
            "title": "Home"
        }, 
        {
            "location": "/#overview", 
            "text": "Django Chroniker is a Python package that allows\nyou to use cron to schedule Django management commands through Django's admin.  Creating cron jobs for Django apps can be a pain, annoying and repetitive.\nWith django-chroniker you simply create a single cron job to run every minute,\npoint it at your site's directory and run  manage.py cron .\nThen, you can create, update and delete jobs through Django's admin.  This is a fork of Weston Nielson's  Chronograph  project.", 
            "title": "Overview"
        }, 
        {
            "location": "/#features", 
            "text": "This package contains the following improvements over the parent Chronograph project:    Allow Django management commands to record their percent-progress and display it in admin. e.g.  from chroniker.models import Job\nJob.update_progress(total_parts=77, total_parts_complete=13)    Improved logging of management command stdout and stderr, and efficiently displaying these in admin.   Creation of the  Monitor  model, a proxy of the  Job  model, to allow easier setup of system and database state monitoring.  Addition of a model for documenting inter-job dependencies as well as flags for controlling job behavior based on these dependencies. e.g. You can configure one job to not run until another job has successfully run, or run at a later date.  Improved support for coordinating job execution in a multi-server environment. e.g. You can configure a job to only run on a specific host or any host.   Unlike some scheduling systems, Chroniker attempts to ensure that every job may\nhave at most only one running instance at any given time. This greatly\nsimplifies scheduling, but necessarily imposes some restrictions. If you need\nto schedule multiple instances of a task to run simultaneously, especially in\nreal-time, consider using a system like  Celery \ninstead.", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "Install the package from PyPI via pip with:  pip install django-chroniker  or directly from github with (warning, this may be less stable than the official release on PyPI):  pip install https://github.com/chrisspen/django-chroniker/tarball/master  Add 'chroniker' and 'django.contrib.sites' to the INSTALLED_APPS list in your settings.py.  If you're using Django 1.7 or higher (which you should be), install Chroniker's models by running:  python manage.py migrate  otherwise run:  python manage.py syncdb", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "In your admin, creating and jobs under the Chroniker section.  If you're in a development setting, you can test your Chroniker-based cron jobs by first checking \"force run\" on your job, and then running:  python manage.py cron  Also, you can simulate a simple cron server that will automatically run any pending cron jobs every N seconds with:  python manage.py cronserver  To allow Chroniker can send email, ensure you have valid email parameters in your settings.py. A very basic example using Gmail might be:  EMAIL_USE_TLS = True\nEMAIL_HOST = 'smtp.gmail.com'\nEMAIL_HOST_USER = 'myusername@gmail.com'\nEMAIL_HOST_PASSWORD = os.environ['GMAILPASS']  You can customize the \"name\" Chroniker uses in its emails with:  CHRONIKER_EMAIL_SENDER = 'Jon Doe'  You can also specify a separate email user for Chroniker with:  CHRONIKER_EMAIL_HOST_USER = 'someotherusername@otherdomain.com'  When installing Chroniker in a production environment, you'll need to add a single cron job that calls  bin/chroniker  or  python manage.py cron .\nWithin the call, you'll need to specify where this script is installed, where your Python virtual environment is located (if you're using one), and where your Django project is located.\nAn example of this might be:   * * * * * /usr/local/myproject/bin/chroniker -e /usr/local/myproject/.env/bin/activate_this.py -p /usr/local/myproject  Run  bin/chroniker --help  for a full listing of options.", 
            "title": "Usage"
        }, 
        {
            "location": "/#settings", 
            "text": "Depending on your usage, there are a few options that could greatly help or harm job scheduling.  CHRONIKER_USE_PID   If this is set to True, the  cron  management command will wait for the previous run to complete using a local PID file.   CHRONIKER_SELECT_FOR_UPDATE   If this is set to True, the Job record  will be locked  when updating job status in the database. This may not be supported on all database backends.   CHRONIKER_CHECK_LOCK_FILE   If this is set to True, chroniker will check for a local lockfile to determine if the job is running or not.  You should set this to True in a single-server environment, and False in a multi-server environment.", 
            "title": "Settings"
        }, 
        {
            "location": "/#maintenance", 
            "text": "If you'd like an easy way to delete old job logs, there is a management command\nthat will do it for you:  cron_clean .  You can use it like so::  python manage.py cron_clean [weeks|days|hours|minutes] [integer]  So, if you want to remove all jobs that are older than a week, you can do the\nfollowing::  python manage.py cron_clean weeks 1  Since this is just a simple management command, you can also easily add it to chroniker , via the admin, so that it will clear out old logs\nautomatically.", 
            "title": "Maintenance"
        }, 
        {
            "location": "/#tools", 
            "text": "There is anther included management command,  cronserver  which can be used\nto test the periodic running of jobs.  It'll print out information to the\nscreen about which job are due and also run them.  Here is how you would use\nit::  python manage.py cronserver  This will start up a process that will check for and run any jobs that are due\nevery 60 seconds.  The interval can be changed by simply passing the number of\nseconds in between runs.  For example, to make the process check for due jobs\nevery 2 minutes, you would run::  python manage.py cronserver 120", 
            "title": "Tools"
        }, 
        {
            "location": "/#architecture", 
            "text": "The trickiest thing to get right in  Chroniker  is the ability to properly\nmanage the state of a  Job , i.e. reliably determining whether or not a\njob is or isn't running, if it has been killed or terminated prematurely.  In\nthe first version of  Chroniker  this issue was \"solved\" by keeping track\nof the PID of each running job and using the  ps  command to have the\noperating system tell us if the job was still running.  However, this route was\nless than ideal, for a few reasons, but most importantly because isn't wasn't\ncross-platform.  Additionally, using a series of  subprocess.Popen  calls was\nleading to path-related issues for some users, even on \"supported\" platforms.  Newer version of  Chroniker  have attempted to solve this problem in the\nfollowing way:  1.  Get a list of ``Job``\\s that are \"due\"\n2.  For each ``Job``, launch a ``multiprocessing.Process`` instance, which\n    internally calls ``django.core.management.call_command``\n3.  When the ``Job`` is run, we spawn a ``threading.Thread`` instance whose\n    sole purpose is to keep track of a lock file.  This thread exists only\n    while the Job is running and updates the file every second.  We store\n    the path to this temporary file (an instance of\n    ``tempfile.NamedTemporaryFile``) on the ``Job`` model (which is then\n    stored in the database).  When we want to check if a ``Job`` is running\n    we do the following:\n\n    1.  If ``is_running`` equals ``True``, and ``lock_file`` point to a\n        file, then:\n\n        1.  If the lock file actually exists and has been updated more\n            recently than ``CHRONIKER_LOCK_TIMEOUT`` seconds, then we\n            can assume that the ``Job`` is still running\n    2.  Else we assume the ``Job`` is not running and update the database\n        accordingly  This new method should would much more reliably across all platforms that\nsupport the threading and multiprocess libraries.", 
            "title": "Architecture"
        }, 
        {
            "location": "/#development", 
            "text": "Tests require the Python development headers to be installed, which you can install on Ubuntu with:  sudo apt-get install python-dev python3-dev python3.4-dev  To run unittests across multiple Python versions, install:  sudo apt-get install python3.4-minimal python3.4-dev python3.5-minimal python3.5-dev  To run all  tests :  export TESTNAME=; tox  To run tests for a specific environment (e.g. Python 2.7 with Django 1.4):  export TESTNAME=; tox -e py27-django15  To run a specific test:  export TESTNAME=.testTimezone2; tox -e py27-django15  To run the  documentation server  locally:  mkdocs serve -a :9999  To  deploy documentation , run:  mkdocs gh-deploy --clean  To build and deploy a versioned package to PyPI, verify  all unittests are passing , and then run:  python setup.py sdist\npython setup.py sdist upload", 
            "title": "Development"
        }
    ]
}